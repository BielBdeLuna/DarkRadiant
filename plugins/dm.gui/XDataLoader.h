#include "XData.h"
#include "ifilesystem.h"
#include "iarchive.h"
#include "parser/DefTokeniser.h"
#include <map>
#include "generic/callback.h"

#include "reportError.h"

#include "debugging/ScopedDebugTimer.h"


namespace readable
{
	namespace
	{
		/* All vectors of XData-objects are initialized with this size so that no sorting is necessary, which
		would otherwise be necessary when e.g. page2_body was defined before page1_body and a simple
		vector.push_back(..) was used to store the data instead of a direct access using an Index. */
		const int	MAX_PAGE_COUNT			= 20;

		const char*	DEFAULT_TWOSIDED_LAYOUT = "guis/readables/books/book_calig_mac_humaine.gui";
		const char*	DEFAULT_ONESIDED_LAYOUT = "guis/readables/sheets/sheet_paper_hand_nancy.gui";
		const char*	DEFAULT_SNDPAGETURN		= "readable_page_turn";

		const char* XDATA_DIR				= "xdata/";
		const char* XDATA_EXT				= "xd";
	}

	typedef std::map<std::string, std::string> StringMap;
	typedef std::vector<XDataPtr> XDataPtrList;
	struct XDataParse
	{
		XDataPtr xData;
		StringList error_msg;
	};

	///////////////////////////// XDataLoader
	// Class for importing XData from files.
	class XDataLoader
	{
	/* ToDo:
		1) Maybe add a public method for refreshing DefMap.		->no!
		2) When a definition couldn't be found refresh the DefMap and try again.			->done
		3) Put the Functor operator and all that stuff into a new class and add a const method pointer, as well as a folder (by Constructor).
		4) Test importing of slash-separated lines.				->fixed
		5) Hide operator() in private using friend statements. 
		6) replace XDataParse by pair.			->no!
		7) StoreContent(), ReadLines() Methods.		->done
		8) Change ReadLines() to automatically switch between single-line and multiline parsing.		->done
		9) ErrorMessages generated by StoreContent should match the definition name.					->done
		10)Definitions in readers could simply be catched and return falsed.		->done
		11)Maybe add detection of \n in xdata files as a error/warning. (Basically not necessary) 
		12)GrabAllDefinitions error response?    -> cerr console.*/		

	public:
		/* Imports a list of XData objects from the File specified by Filename (just the name, not the path).
		Throws runtime_error exceptions if opening the file failed or if its extension is not xd. Every other
		error-output is linked to the cerr-console.*/
		XDataPtrList import(const std::string& FileName);

		// Required type for the Callback to work.
		typedef const std::string& first_argument_type;

		// Functor operator: Adds all definitions found in the target file to the DefMap.
		void operator() (const std::string& filename);

	private:
		StringMap DefMap;

		/* Checks WHERE the content following in the tokenizer has to be stored. DefName is the name of the
		definition for whom content is parsed and is just used for error-messages. */
		bool StoreContent(const std::string& Where, parser::DefTokeniser& tok, const std::string& DefName);

		/* Parses a single definition from a stream into an XData object an generates warning and error messages. */
		bool parseXDataDef(parser::DefTokeniser& tok);

		/* Skips the ":" and parses the following SingleLine or MultiLine content into What.*/
		bool ReadLines(parser::DefTokeniser& tok, std::string& What);

		/* Generates a map that stores all definitions found in all .xd-files and the corresponding .xd-file. */
		void grabAllDefinitions();

		/* Used to jump out of a definition. Can lead to undefined behavior on Syntax-errors. */
		void jumpOutOfBrackets(parser::DefTokeniser& tok, int CurrentDepth);

	//Helper-variables for import:
		XDataParse _NewXData;
		std::string _name;
		StringList _guiPageError;
		int _maxPageCount;
		int _maxGuiNumber;
		std::string _guiPageDef;
		int _numPages;
		std::string _sndPageTurn;
		StringList _guiPage;

	};
}
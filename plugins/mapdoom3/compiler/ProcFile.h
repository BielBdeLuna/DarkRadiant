#pragma once

#include <boost/shared_ptr.hpp>
#include <vector>
#include "ibrush.h"
#include "ipatch.h"
#include "ishaders.h"

#include "math/AABB.h"
#include "render/ArbitraryMeshVertex.h"

#include "PlaneSet.h"
#include "ProcWinding.h"
#include "ProcLight.h"

namespace map
{

struct HashVertex;
struct OptVertex; 

// chains of ProcTri are the general unit of processing
struct ProcTri
{
	MaterialPtr			material;
	//void *				mergeGroup;		// we want to avoid merging triangles
											// from different fixed groups, like guiSurfs and mirrors
	int					planeNum;			// not set universally, just in some areas

	ArbitraryMeshVertex	v[3];

	const HashVertex*	hashVert[3];		// for T-junction pass
	OptVertex*			optVert[3];			// for optimization
};
typedef std::vector<ProcTri> ProcTris;

struct ProcFace
{
	std::size_t			planenum;		// serves as index into ProcFile::planes

	MaterialPtr			material;		// the material of this plane
	//textureVectors_t	texVec;			// FIXME

	ProcWinding			winding;		// only clipped to the other sides of the brush
	ProcWinding			visibleHull;	// also clipped to the solid parts of the world
};

struct ProcBrush;
typedef boost::weak_ptr<ProcBrush> ProcBrushWeakPtr;

// A brush structure used during compilation
struct ProcBrush
{
	//ProcBrush*			next;
	ProcBrushWeakPtr	original;	// chopped up brushes will reference the originals

	std::size_t			entitynum;			// editor numbering for messages
	std::size_t			brushnum;			// editor numbering for messages

	MaterialPtr			contentShader;	// one face's shader will determine the volume attributes

	int					contents;
	bool				opaque;
	int					outputNumber;		// set when the brush is written to the file list

	AABB				bounds;

	typedef std::vector<ProcFace> ProcFaces;
	ProcFaces			sides;
};
typedef boost::shared_ptr<ProcBrush> ProcBrushPtr;

// A primitive can either be a brush or a patch,
// so only one of the pointers is non-NULL
struct ProcPrimitive
{
	ProcBrushPtr	brush;
	ProcTris		patch;	// this is empty for brushes
};

struct ProcEntity
{
	// The reference into the scenegraph
	IEntityNodePtr	mapEntity;

	Vector3			origin;

	// Each entity has 0..N primitives
	typedef std::vector<ProcPrimitive> Primitives;
	Primitives		primitives;

	//struct tree_s *		tree;

	//int					numAreas;
	//uArea_t *			areas;

	ProcEntity(const IEntityNodePtr& entityNode) :
		mapEntity(entityNode)
	{}
};

/**
 * This class represents the processed data (entity models and shadow volumes)
 * as generated by the dmap compiler. Use the saveToFile() method to write the
 * data into the .proc file.
 */
class ProcFile
{
public:
	typedef std::vector<ProcEntity> ProcEntities;
	ProcEntities entities;

	// All the planes in the map
	PlaneSet planes;

	std::size_t numPortals;
	std::size_t numPatches;
	std::size_t numWorldBrushes;
	std::size_t numWorldTriSurfs;

	AABB mapBounds;

	typedef std::vector<ProcLight> ProcLights;
	ProcLights lights;

	ProcFile() :
		numPortals(0),
		numPatches(0),
		numWorldBrushes(0),
		numWorldTriSurfs(0)
	{}

	void saveToFile(const std::string& path)
	{
		// TODO
	}

	static const char* const Extension()
	{
		return ".proc";
	}
};
typedef boost::shared_ptr<ProcFile> ProcFilePtr;

} // namespace
